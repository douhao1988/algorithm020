# 一、深度优先搜索(DFS)和广度优先搜索(BFS)

> 深度优先搜索和广度优先搜索，都是图形搜索算法，它两相似，又却不同，在应用上也被用到不同的地方。

## 1.1、深度优先搜索

深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法，英文缩写为 DFS 即 Depth First Search。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现 DFS 算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

## 1.2、广度优先搜索

广度优先搜索（也称宽度优先搜索，缩写 BFS，以下采用广度来描述）是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。Dijkstra 单源最短路径算法和 Prim 最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫 BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。基本过程，BFS 是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现 BFS 算法。

## 1.3、算法模板

### 1.3.1、DFS

```javascript
// 递归版本
const visited = new Set();
const dfs = (node) => {
  if (visited.has(node)) return;
  visited.add(node);
  dfs(node.left);
  dfs(node.right);
};

// 非递归版本

function dfs(root) {
  const ans = [];
  if (!root) return [];
  const stack = [];
  stack.push(root);
  while (stack.length != 0) {
    const item = stack.pop();
    ans.push(item);
    const children = item.children;
    for (var i = children.length - 1; i >= 0; i--) {
      stack.push(children[i]);
    }
  }
  return ans;
}
```

### 1.3.2、BFS

```javascript
const bfs = (root) => {
  let result = [],
    queue = [root];
  while (queue.length > 0) {
    let level = [],
      n = queue.length;
    for (let i = 0; i < n; i++) {
      let node = queue.pop();
      level.push(node.val);
      if (node.left) queue.unshift(node.left);
      if (node.right) queue.unshift(node.right);
    }
    result.push(level);
  }
  return result;
};
```

# 二、贪心算法

> 顾名思义，贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪心算法得到的最终结果也是整体最优的。虽然贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。

<hr>

**解题步骤**

- 建立数学模型来描述问题。
- 把求解的问题分成若干个子问题。
- 对每个子问题求解，得到子问题的局部最优解。
- 把子问题的解局部最优解合成原来解问题的一个解。

## 2.1、贪心算法的基本要素

**1.贪心选择性质**

一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次的选择可以依赖以前作出的选择，但不依赖于后面要作出的选择。

**2.最优子结构性质**

当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。

## 2.2、贪心算法的应用策略

贪心算法不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优选择。使用贪心策略要注意局部最优与全局最优的关系，选择当前的局部最优并不一定能推导出问题的全局最优。需要注意以下两个问题：

1.该问题是否适合使用贪心策略求解，也就是该问题是否具有贪心选择性质

2.制定贪心策略，以达到问题的最优解或较优解

要确定一个问题是否适合用贪心算法求解，必须证明每一步所作的贪心选择最终导致问题的整体最优解。证明的大致过程为：首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。然后用数学归纳法证明通过每一步做贪心选择，最终可得到问题的整体最优解。

### 2.3、贪心算法存在的问题

1、不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑；  
2、贪心算法一般用来解决求最大或最小解；  
3、贪心算法只能确定某些问题的可行性范围。

# 三、二分查找

二分查找是一种算法，它是一种效率较高的查找方法。，其输入是一个有序的元素列表（必须是有序的），如果查找的元素包含在列表中，二分查找返回其位置，否则返回 NULL

## 3.1、解题模板

```javascript
let left = 0,
  right = len(array) - 1;
while (left <= right) {
  let mid = (left + right) >> 1;
  if (array[mid] === target) {
    /*find the target*/ return;
  } else if (array[mid] < target) left = mid + 1;
  else right = mid - 1;
}
```

## 3.2、二分查找算法的原理

- 如果待查序列为空，那么就返回-1，并退出算法；这表示查找不到目标元素。

- 如果待查序列不为空，则将它的中间元素与要查找的目标元素进行匹配，看它们是否相等。

- 如果相等，则返回该中间元素的索引，并退出算法；此时就查找成功了。

- 如果不相等，就再比较这两个元素的大小。

- 如果该中间元素大于目标元素，那么就将当前序列的前半部分作为新的待查序列；这是因为后半部分的所有元素都大于目标元素，它们全都被排除了。

- 如果该中间元素小于目标元素，那么就将当前序列的后半部分作为新的待查序列；这是因为前半部分的所有元素都小于目标元素，它们全都被排除了。

- 在新的待查序列上重新开始第 1 步的工作。

二分查找之所以快速，是因为它在匹配不成功的时候，每次都能排除剩余元素中一半的元素。因此可能包含目标元素的有效范围就收缩得很快，而不像顺序查找那样，每次仅能排除一个元素。
